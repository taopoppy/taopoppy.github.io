(window.webpackJsonp=window.webpackJsonp||[]).push([[217],{402:function(v,_,o){"use strict";o.r(_);var e=o(0),t=Object(e.a)({},function(){var v=this,_=v.$createElement,o=v._self._c||_;return o("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[o("h1",{attrs:{id:"node是什么"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#node是什么","aria-hidden":"true"}},[v._v("#")]),v._v(" node是什么")]),v._v(" "),o("h2",{attrs:{id:"到底什么是node"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#到底什么是node","aria-hidden":"true"}},[v._v("#")]),v._v(" 到底什么是node")]),v._v(" "),o("p",[v._v("如果有人问你到底什么是"),o("code",[v._v("node")]),v._v(",可以用一句话来回答，因为这句话基本上包含了"),o("code",[v._v("node")]),v._v("的本质和其作用：")]),v._v(" "),o("p",[o("font",{attrs:{color:"#3eaf7c"}},[v._v("Node不是一门语言，也不是一个框架，是基于Chrome V8引擎的JavaScript运行时环境；同时结合libuv扩展了JavaScript的功能，使得JavaScript能够支持浏览器Dom的操作，同时具有了后端语言才有的I/O，文件读写和操作数据库的能力，是目前最简单的全栈环境")])],1),v._v(" "),o("p",[v._v("因为大道至简，任何知识当你理解到一种程度的时候就可以用一句话来总结，但是实际上任何知识点如果你要开始学习它，都不是一句话能学的懂的，所以作为前端程序员我们首先要知道为什么"),o("code",[v._v("Node")]),v._v("选择了"),o("code",[v._v("JavaScript")]),v._v("，因为")]),v._v(" "),o("ul",[o("li",[o("font",{attrs:{color:"#3eaf7c"}},[v._v("语言的语法结构简单，进行数据提取和分析就越容易，用来开发互联网应用也就越简单，如果对象创建和线程管理都不是必须的，那么基于原型而不是面向对象的JavaScript就是最完美的")])],1)]),v._v(" "),o("p",[v._v("这也印证了万维网之父Tim-Berners-Lee的那句话：")]),v._v(" "),o("ul",[o("li",[o("font",{attrs:{color:"#CC99CD"}},[v._v("任何可以使用JavaScript实现的应用，最终都用JavaScript实现")])],1)]),v._v(" "),o("p",[v._v("所以当你使用"),o("code",[v._v("node")]),v._v("时间久了你就会有这样一种感觉："),o("font",{attrs:{color:"#1E90FF"}},[v._v("前端工程师在Chrome里写JavaScript控制浏览器，Node.js让你用类似的方式来控制整个计算机")])],1),v._v(" "),o("h2",{attrs:{id:"node概述"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#node概述","aria-hidden":"true"}},[v._v("#")]),v._v(" node概述")]),v._v(" "),o("p",[v._v("在官网有段关于"),o("code",[v._v("node")]),v._v("的描述如下：")]),v._v(" "),o("p",[o("code",[v._v("Node.js is a JavaScript runtime built on Chrome's V8 engine. Node.js uses an event-driven , non-block I/O model that makes it lightweight and efficient, Node.js' package ecosystem,npm, is the largest ecosystem of open source libraries in the world")])]),v._v(" "),o("ul",[o("li",[o("p",[v._v("首先最重要的就是node的本质是"),o("code",[v._v("JavaScript")]),v._v("环境运行时，因为在过去"),o("code",[v._v("JavaScript")]),v._v("只能在浏览器当中运行，而因为浏览器当中有"),o("code",[v._v("JS引擎")]),v._v("，它可以帮助浏览器去识别和执行"),o("code",[v._v("JavaScript")]),v._v("语言，但是浏览器是每个不同厂家的产品，其实使用的引擎也不一样，而作为最近十年表现优异的"),o("code",[v._v("V8引擎")]),v._v("也帮助Chrome浏览器在市场独占鳌头，所以有人把它拿出来做了修改，让"),o("code",[v._v("V8引擎")]),v._v("可以单独运行在别的地方，也致使"),o("code",[v._v("JavaScript")]),v._v("脱离的浏览器也可以运行，所谓环境运行时，就是"),o("code",[v._v("JavaScript")]),v._v("可以运行的平台。")])]),v._v(" "),o("li",[o("p",[o("code",[v._v("JavaScript")]),v._v("和"),o("code",[v._v("C++")]),v._v("有着千丝万缕的联系。因为"),o("code",[v._v("V8引擎")]),v._v("是通过"),o("code",[v._v("C++")]),v._v("来编写的，但是实际上这种底层语言的学习成本和使用成本都很大，我们编写的"),o("code",[v._v("JavaScript")]),v._v("实际上要转化成为这种"),o("code",[v._v("C++")]),v._v("去运行的，同时在"),o("code",[v._v("node")]),v._v("当中I/O都是异步的，全部要交给由"),o("code",[v._v("C++")]),v._v("编写的"),o("code",[v._v("libuv")]),v._v("这个事件循环库来处理，简化了并发模型。")])]),v._v(" "),o("li",[o("p",[o("code",[v._v("Node")]),v._v("的目标是让并发变的简单，而使用的这种"),o("font",{attrs:{color:"#3eaf7c"}},[v._v("事件循环")]),v._v("和"),o("font",{attrs:{color:"#3eaf7c"}},[v._v("非阻塞I/O模型")]),v._v("让在以网络编程为主的I/O密集的应用当中脱引而出。但是这两个名词概念有点生疏，我们下面来说一下这个两个概念。")],1)])]),v._v(" "),o("h3",{attrs:{id:"_1-非阻塞i-o"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_1-非阻塞i-o","aria-hidden":"true"}},[v._v("#")]),v._v(" 1. 非阻塞I/O")]),v._v(" "),o("p",[v._v("首先"),o("code",[v._v("I/O")]),v._v("是"),o("code",[v._v("input")]),v._v("和"),o("code",[v._v("output")]),v._v("的缩写，表示计算机输入输出的意思，除了常见的键盘，显示器，打印机都是输入输出设备，对计算机来说读写磁盘和网络操作都是"),o("code",[v._v("I/O")]),v._v("操作，当然数据库的操作也算，因为数据库也在磁盘当中。")]),v._v(" "),o("p",[v._v("我们先来看看"),o("font",{attrs:{color:"#CC99CD"}},[v._v("阻塞I/O")]),v._v("："),o("code",[v._v("I/O")]),v._v("的时候进程休眠等待"),o("code",[v._v("I/O")]),v._v("完成后进入下一步。如果不考虑跳转语句，普通的程序是逐条执行的，当程序走到"),o("code",[v._v("I/O")]),v._v("操作的时候，程序会调用操作系统更底层的命令来完成操作，期间程序就会等待底层命令返回结果。拿到结果才能进行下一条程序语句的执行，"),o("font",{attrs:{color:"#3eaf7c"}},[v._v("我们把程序等待底层命令结果返回的这种行为或者现象称之为阻塞")])],1),v._v(" "),o("p",[o("font",{attrs:{color:"#CC99CD"}},[v._v("非阻塞I/O")]),v._v("："),o("code",[v._v("I/O")]),v._v("时函数立即返回，进程不等待"),o("code",[v._v("I/O")]),v._v("完成。程序进行到"),o("code",[v._v("I/O")]),v._v("操作的时候，主程序开始调用底层命令，但是主程序并不会一直等待底层命令的返回，而是执行下一条程序语句。然后等到底层"),o("code",[v._v("I/O")]),v._v("有结果返回的时候，主程序再去决定丢弃还是处理。")],1),v._v(" "),o("p",[v._v("但是计算机指令都可以理解为阻塞的，为什么偏偏"),o("code",[v._v("I/O")]),v._v("操作就是特殊的呢？简单来说: 大部分的指令都依赖于"),o("code",[v._v("CPU")]),v._v("运算，因为到当下来说"),o("code",[v._v("CPU")]),v._v("运行速度极其的快，一秒能执行30亿条语句，非"),o("code",[v._v("I/O")]),v._v("操作压根感觉不到阻塞，但是"),o("code",[v._v("I/O")]),v._v("操作更慢，比如拷贝电影文件，这都是肉眼看得见的慢。")]),v._v(" "),o("h3",{attrs:{id:"_2-事件驱动"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_2-事件驱动","aria-hidden":"true"}},[v._v("#")]),v._v(" 2. 事件驱动")]),v._v(" "),o("p",[v._v("前面我们说"),o("code",[v._v("I/O")]),v._v("操作完成后主程序会感知到，但是一定会有一种机制，就是主程序啥时候知道"),o("code",[v._v("I/O")]),v._v("操作完成，或者说完成的结果以怎么样的方式告诉主程序？")]),v._v(" "),o("p",[v._v("非阻塞的"),o("code",[v._v("I/O")]),v._v("认为立即完成的，同时发射一个事件并写好这个事件的处理函数，底层"),o("code",[v._v("I/O")]),v._v("操作完成后触发这个事件并执行相关的处理函数，内部的实现实际上是一个"),o("font",{attrs:{color:"#3eaf7c"}},[v._v("观察者模式")])],1),v._v(" "),o("h2",{attrs:{id:"node架构模式"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#node架构模式","aria-hidden":"true"}},[v._v("#")]),v._v(" node架构模式")]),v._v(" "),o("img",{attrs:{src:v.$withBase("/node_mode.jpg"),alt:"node早期的架构"}}),v._v(" "),o("p",[v._v("首先"),o("code",[v._v("libuv")]),v._v("由"),o("font",{attrs:{color:"#3eaf7c"}},[v._v("事件循环")]),v._v("和"),o("font",{attrs:{color:"#3eaf7c"}},[v._v("线程池")]),v._v("组成，负责所有I/O任务的分发和执行 "),o("code",[v._v("Node.js")]),v._v("是由事件循环来分发I/O任务，由工作线程将人物分发到线程池当中，事件循环只需要等待执行结果即可。这就是"),o("code",[v._v("node")]),v._v("的架构模式，我们下面来解释一下为什么是这样：")],1),v._v(" "),o("ul",[o("li",[v._v("因为JS是单线程,单线程的特点就是同同一时间只能干一件事，所有任务都需要排队挨个执行。")]),v._v(" "),o("li",[v._v("而CPU是空闲的，它完全可以不管I/O设备而直接挂起处于等待中的任务，先运行排在后面的任务")]),v._v(" "),o("li",[v._v("将等待的I/O任务放在事件循环中，但是I/O任务分为"),o("font",{attrs:{color:"#3eaf7c"}},[v._v("文件I/O")]),v._v("和"),o("font",{attrs:{color:"#3eaf7c"}},[v._v("网络I/O")]),v._v(", 可以看到文件I/O是在线程池中进行的，而网络I/O是不通过线程池完成的。")],1)]),v._v(" "),o("h2",{attrs:{id:"node的特点"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#node的特点","aria-hidden":"true"}},[v._v("#")]),v._v(" node的特点")]),v._v(" "),o("p",[o("code",[v._v("Node")]),v._v("由4个很重要的特点就是："),o("font",{attrs:{color:"#3eaf7c"}},[v._v("适合构建WEB应用")]),v._v("、"),o("font",{attrs:{color:"#3eaf7c"}},[v._v("高性能")]),v._v("、 "),o("font",{attrs:{color:"#3eaf7c"}},[v._v("简单")]),v._v("、 "),o("font",{attrs:{color:"#3eaf7c"}},[v._v("可扩展")])],1),v._v(" "),o("h3",{attrs:{id:"_1-适合构建web应用"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_1-适合构建web应用","aria-hidden":"true"}},[v._v("#")]),v._v(" 1. 适合构建WEB应用")]),v._v(" "),o("ul",[o("li",[o("p",[o("font",{attrs:{color:"#CC99CD"}},[v._v("构建网站")]),v._v("\n传统的开发都是一体式的，视图渲染还有数据库访问，基本上都在一个项目当中，和传统的"),o("code",[v._v("java")]),v._v("还有"),o("code",[v._v("php")]),v._v("没有太大区别;")],1)]),v._v(" "),o("li",[o("p",[o("font",{attrs:{color:"#CC99CD"}},[v._v("构建API")]),o("br"),v._v("\n多端应用将"),o("code",[v._v("API")]),v._v("接口开发推向了浪尖，各种风格的接口开发琳琅满目，比如"),o("font",{attrs:{color:"#3eaf7c"}},[v._v("GitHub V3版的RESTful API")]),v._v("、 "),o("font",{attrs:{color:"#3eaf7c"}},[v._v("微博API的自定义约定")]),v._v("，包括最新的"),o("font",{attrs:{color:"#3eaf7c"}},[v._v("GraphQL")]),v._v("。但是大型工程当中的"),o("code",[v._v("API")]),v._v("比较复杂，"),o("font",{attrs:{color:"#3eaf7c"}},[v._v("因此在后端的API接口开发上封装一层专门供前端使用的 API Proxy是很有必要的")]),v._v("。所以这个在后面我们也会讲。")],1)]),v._v(" "),o("li",[o("p",[o("font",{attrs:{color:"#CC99CD"}},[v._v("构建RPC服务")]),v._v(" "),o("code",[v._v("RPC协议服务")]),v._v("也叫做远程过程调用，常见的做法就是将数据库访问返回的数据以"),o("code",[v._v("TCP")]),v._v("形式传输给调用方，在协议和传输上有明显的优势，比如像著名的"),o("code",[v._v("RPC")]),v._v("服务有"),o("code",[v._v("Java")]),v._v("版本的"),o("code",[v._v("Dubbo")]),v._v("。"),o("code",[v._v("Google")]),v._v("出品的跨语言"),o("code",[v._v("RPC")]),v._v("库"),o("code",[v._v("gRPC")]),v._v(",当然"),o("code",[v._v("Node")]),v._v("实现的"),o("code",[v._v("RPC")]),v._v("库也有很多，例如使用纯粹用"),o("code",[v._v("Node")]),v._v("实现的"),o("code",[v._v("DNode")]),v._v(",微服务工具集"),o("code",[v._v("Seneca")]),v._v(",跨语言的"),o("code",[v._v("gRPC")]),v._v("客户端，可以看出"),o("code",[v._v("Node")]),v._v("在微服务下的使用场景也是非常多的。")],1)]),v._v(" "),o("li",[o("p",[o("font",{attrs:{color:"#CC99CD"}},[v._v("前后端分离")]),v._v("\n前端分离的应用场景有："),o("font",{attrs:{color:"#3eaf7c"}},[v._v("前端页面静态化（page static）")]),v._v("、"),o("font",{attrs:{color:"#3eaf7c"}},[v._v("前端页面服务化（PAAS）")]),v._v("、"),o("font",{attrs:{color:"#3eaf7c"}},[v._v("服务端渲染（SSR）")]),v._v("、"),o("font",{attrs:{color:"#3eaf7c"}},[v._v("渐进式Web应用（PWA）")])],1)]),v._v(" "),o("li",[o("p",[o("font",{attrs:{color:"#CC99CD"}},[v._v("适用于Serverless")]),v._v("\n有关运维，"),o("code",[v._v("API")]),v._v("快速开发，服务端渲染问题都能通过Serverless来解决，开发者不需要去关心运维，流量处理和容器编排，通过一个函数（函数内置RPC,缓存，配置等）就能完成所有开发，可以简单理解为"),o("code",[v._v("Serveless")]),v._v("是云计算的延时，而"),o("code",[v._v("Node.js")]),v._v("在这方面有得天独厚的优势。")],1)])]),v._v(" "),o("h3",{attrs:{id:"_2-高性能"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_2-高性能","aria-hidden":"true"}},[v._v("#")]),v._v(" 2. 高性能")]),v._v(" "),o("ul",[o("li",[o("p",[o("font",{attrs:{color:"#CC99CD"}},[v._v("执行速度开")]),v._v("\n构建在优秀的"),o("code",[v._v("V8")]),v._v("引擎上，执行速度在动态语言中算最快的")],1)]),v._v(" "),o("li",[o("p",[o("font",{attrs:{color:"#CC99CD"}},[v._v("天生异步")]),v._v(" "),o("font",{attrs:{color:"#3eaf7c"}},[v._v("事件驱动")]),v._v("和"),o("font",{attrs:{color:"#3eaf7c"}},[v._v("非阻塞I/O")]),v._v("特性决定了必须要采用异步的方式，实际上"),o("font",{attrs:{color:"#3eaf7c"}},[v._v("每个I/O都是异步的")]),v._v("，因此集成到"),o("code",[v._v("libuv")]),v._v("中才会让开发者感觉不到并发的存在。")],1)])]),v._v(" "),o("h3",{attrs:{id:"_3-简单可扩展"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_3-简单可扩展","aria-hidden":"true"}},[v._v("#")]),v._v(" 3. 简单可扩展")]),v._v(" "),o("ul",[o("li",[v._v("语法简单，并发编程简单，部署运维简单，开发简单，可以使用大量的"),o("code",[v._v("npm")]),v._v("模块，也可以通过编写"),o("code",[v._v("C++")]),v._v("实现"),o("code",[v._v("CPU")]),v._v("密集型任务")])]),v._v(" "),o("h2",{attrs:{id:"node和web"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#node和web","aria-hidden":"true"}},[v._v("#")]),v._v(" node和Web")]),v._v(" "),o("p",[v._v("上面我们说到"),o("code",[v._v("node")]),v._v("在"),o("code",[v._v("Web")]),v._v("这种高并发、I/O密集场景性能上优势很明显，下面我们就要好好说一说原因。")]),v._v(" "),o("p",[o("strong",[v._v("1.I/O密集")])]),v._v(" "),o("p",[v._v("我们先说一下"),o("code",[v._v("I/O")]),v._v("密集和"),o("code",[v._v("CPU")]),v._v("密集，以及为什么"),o("code",[v._v("Web")]),v._v("属于"),o("code",[v._v("I/O")]),v._v("密集。")]),v._v(" "),o("ul",[o("li",[o("font",{attrs:{color:"#CC99CD"}},[v._v("CPU密集")]),v._v("：程序大部分用来做计算和逻辑处理，比如牙所，解压，加密，解密等等")],1),v._v(" "),o("li",[o("font",{attrs:{color:"#CC99CD"}},[v._v("I/O密集")]),v._v("：程序大部分用来做存取设备，网络设施的一些读取操作，以及数据库的读取，比如文件操作，网络操作，数据库")],1)]),v._v(" "),o("p",[o("strong",[v._v("2.web常见场景")])]),v._v(" "),o("p",[v._v("然后为什么在"),o("code",[v._v("Web")]),v._v("常常属于"),o("code",[v._v("I/O")]),v._v("密集，我们来看看web常见场景；")]),v._v(" "),o("ul",[o("li",[o("p",[o("font",{attrs:{color:"#CC99CD"}},[v._v("静态资源读取")]),v._v("\n基本上网络当中静态资源的获取都是要从服务器上获取，服务器这些资源是放在服务器的硬盘上的，所以对于服务器就是静态资源读取，属于文件操作，属于"),o("code",[v._v("I/O")]),v._v("密集。")],1)]),v._v(" "),o("li",[o("p",[o("font",{attrs:{color:"#CC99CD"}},[v._v("数据库操作")]),v._v("\n动态数据和信息都是要读取数据库的，当然也有少部分的"),o("code",[v._v("CPU")]),v._v("处理，但是慢的还是"),o("code",[v._v("I/O")]),v._v("操作")],1)]),v._v(" "),o("li",[o("p",[o("font",{attrs:{color:"#CC99CD"}},[v._v("渲染页面")]),v._v("\n读取模板也是属于"),o("code",[v._v("I/O")]),v._v("操作，因为属于文件读取么")],1)])]),v._v(" "),o("h2",{attrs:{id:"高并发应对之道"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#高并发应对之道","aria-hidden":"true"}},[v._v("#")]),v._v(" 高并发应对之道")]),v._v(" "),o("h3",{attrs:{id:"_1-进程和线程"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_1-进程和线程","aria-hidden":"true"}},[v._v("#")]),v._v(" 1. 进程和线程")]),v._v(" "),o("ul",[o("li",[o("p",[o("font",{attrs:{color:"#CC99CD"}},[v._v("进程")]),v._v("：是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位\n这种解释简直不能理解，因为比如说我们的音乐播放器或者电影播放器都是一个程序，双击图标，这段程序就会在电脑的内存中执行，"),o("font",{attrs:{color:"#3eaf7c"}},[v._v("所以在内存当中运行的程序就是一个进程")]),v._v("，")],1)]),v._v(" "),o("li",[o("p",[o("font",{attrs:{color:"#CC99CD"}},[v._v("多进程")]),v._v("：启用多个进程，多个进程可以一起执行多个任务（好比一台电脑能同时听音乐和同时写代码）")],1)]),v._v(" "),o("li",[o("p",[o("font",{attrs:{color:"#CC99CD"}},[v._v("线程")]),v._v("：进程内一个相对独立，可调度的执行单元，与同属于一个进程当中的其他线程共享进程的资源")],1)]),v._v(" "),o("li",[o("p",[o("font",{attrs:{color:"#CC99CD"}},[v._v("多线程")]),v._v("：启动一个进程，在一个进程内启动多个线程，这样多个线程也可以一块执行多个任务（好比一个音乐播放器中，又能听音乐，又能同时发评论）")],1)])]),v._v(" "),o("h3",{attrs:{id:"_2-node工作模型"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_2-node工作模型","aria-hidden":"true"}},[v._v("#")]),v._v(" 2. node工作模型")]),v._v(" "),o("p",[o("code",[v._v("node")]),v._v("的工作模型或者架构我们在上面已经说过了，有关"),o("font",{attrs:{color:"#3eaf7c"}},[v._v("事件循环")]),v._v("和"),o("font",{attrs:{color:"#3eaf7c"}},[v._v("费阻塞I/O")]),v._v("我们这里依然有必有再说一下，这次我们将用最通俗的语言来讲，并且解释为什么这种模型能面对高并发\n"),o("img",{attrs:{src:v.$withBase("/node_work.png"),alt:"node工作模型"}})],1),v._v(" "),o("p",[v._v("在此之前我们先说说传统的"),o("code",[v._v("java apache")]),v._v("是怎么工作的。面对用户访问，它是每次一个用户访问进来就要开启一个进程，在这个进程中进行"),o("code",[v._v("CPU")]),v._v("对请求分析，然后再进行"),o("code",[v._v("I/O")]),v._v("操作。好比一个饭店是这样的工作模式，一个服务员配对一个大厨，这个服务员就是"),o("code",[v._v("CPU")]),v._v(",大厨就是"),o("code",[v._v("I/O")]),v._v(",他们属于一个进程里的东西，服务员点菜，然后交给同一个进程中的大厨去进行"),o("code",[v._v("I/O")]),v._v("操作。但是这个模式有两个特别明显的缺点：")]),v._v(" "),o("ul",[o("li",[o("font",{attrs:{color:"#3eaf7c"}},[v._v("一个服务器最大进程数有限")]),v._v(" ，比如最大可以开5000个进程，那就说明同时只能处理5000个用户访问，第5001个用户就得等着（这就好比饭店中有30个服务员和30个大厨，第30个客人来就要等，等到哪个大厨做完才能开始点菜）")],1),v._v(" "),o("li",[o("font",{attrs:{color:"#3eaf7c"}},[v._v("CPU被严重浪费")]),v._v(" ，同时开5000个进程，一个进程完全处理一个请求需要10分钟，但是"),o("code",[v._v("CPU")]),v._v("处理的速度远远大于"),o("code",[v._v("I/O")]),v._v(",导致进程处于在"),o("code",[v._v("I/O")]),v._v("操作的时候，进程中分配的"),o("code",[v._v("CPU")]),v._v("是空闲的（好比服务员点菜需要一分钟，而大厨做菜需要30分钟，导致服务员在大厨做饭的时候没事干，玩手机）")],1)]),v._v(" "),o("p",[v._v("相比之下，我们上图中"),o("code",[v._v("node")]),v._v("的工作模型就完美的解决了问题，面对用户的访问，只开一个单线程，这个单线程当中处理所有用户的请求分析，但是所有"),o("code",[v._v("I/O")]),v._v("的操作都交个多线程去做，这种模型就好比一个饭店只招一个服务员，但是有很多大厨，服务员可以不停的点菜，大厨可以不停的做菜，而且做好了就告诉服务员，服务员按号码给顾客上菜即可，当然顺序也是不一定，谁的菜先好了就给谁。这样的模型就不会怕客人多，服务员也不会空闲。虽然大厨做菜的这个时间是没有办法缩短的，但是服务员的利用率提高了，也就是"),o("code",[v._v("CPU")]),v._v("利用率提高了，同时无论多少客人来都不会等待点菜，只会等待做菜。")]),v._v(" "),o("p",[v._v("但是我们特别要注意的就是在上图这个模型中，事件循环（Event Lopp）是"),o("font",{attrs:{color:"#3eaf7c"}},[v._v("单线程")]),v._v("的，也就是只开一个进程，这个进程里只有一个线程。而非阻塞"),o("code",[v._v("I/O")]),v._v("(Non-blocking)是"),o("font",{attrs:{color:"#3eaf7c"}},[v._v("多线程")]),v._v("的，这里是操作系统在调度自己的多进程多进程，和"),o("code",[v._v("Node")]),v._v("开启的单线程没啥关系。"),o("font",{attrs:{color:"#3eaf7c"}},[v._v("所以Nodejs当中的单线程只针对主进程，I/O操作系统底层是多线程调度")])],1),v._v(" "),o("p",[v._v("当然还有一个误区就是很多人认为"),o("code",[v._v("Node")]),v._v("没有办法使用多"),o("code",[v._v("CPU")]),v._v(",什么意思，就是很多小伙伴认为一个电脑有8核，起了一个"),o("code",[v._v("node")]),v._v("服务只占1核，剩下的7核都浪费了。实际上不是这样，因为在"),o("code",[v._v("node")]),v._v("当中有个"),o("code",[v._v("Cluster")]),v._v("的模块，专门解决多核并发问题，使用这个模块"),o("code",[v._v("cpu")]),v._v("有几个核我们就起几个进程。所以"),o("font",{attrs:{color:"#3eaf7c"}},[v._v("单线程并不是单进程")])],1),v._v(" "),o("h3",{attrs:{id:"_3-高并发应对之道"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_3-高并发应对之道","aria-hidden":"true"}},[v._v("#")]),v._v(" 3.高并发应对之道")]),v._v(" "),o("p",[v._v("高并发就是单位时间内的访问量比较大，我们来说一下从传统到现在的应对高并发的方法")]),v._v(" "),o("ul",[o("li",[o("font",{attrs:{color:"#CC99CD"}},[v._v("增加机器数")]),v._v("：相同大的流量，通过负载均衡分发到不同的机器上来应对高并发")],1),v._v(" "),o("li",[o("font",{attrs:{color:"#CC99CD"}},[v._v("提高机器的质量")]),v._v("：计算需求高的提高"),o("code",[v._v("CPU")]),v._v("的核数和质量，然后"),o("code",[v._v("I/O")]),v._v("需求高的就买好一点的，硬盘质量好的机器。这种方法就和使用什么语言就没啥关系了")],1),v._v(" "),o("li",[o("font",{attrs:{color:"#3eaf7c"}},[v._v("node完美解决高并发，I/O密集的Web场景")]),v._v("：node高性能的场景是一定有前提的，就是两个前提，一个高并发，一个"),o("code",[v._v("I/O")]),v._v(",试想一下如果是"),o("code",[v._v("CPU")]),v._v("密集，可以在事件循环处就卡住了，好比一个人上来就点满汉全席，一个一个菜挨着点，那服务员肯定会卡住的。")],1)])])},[],!1,null,null,null);_.default=t.exports}}]);